<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cura.tor | Smart Contact Curation</title>

    <!-- PWA Meta Tags -->
    <meta name="description" content="Scan and curate business cards with smart OCR technology">
    <meta name="theme-color" content="#020617">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Cura.tor">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Cura.tor">
    <meta name="msapplication-TileColor" content="#020617">
    <meta name="msapplication-TileImage" content="/icons/icon-144.png">

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-72.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/icon-152.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/icons/icon-128.png">

    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <!-- Google Identity Services for OAuth -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <!-- Google API Client -->
    <script src="https://apis.google.com/js/api.js" async defer></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #020617;
            color: #e2e8f0;
            margin: 0;
        }

        .glass {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .gradient-text {
            background: linear-gradient(135deg, #f1f5f9 0%, #94a3b8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .bg-glow {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 30%, rgba(79, 70, 229, 0.15) 0%, transparent 40%), radial-gradient(circle at 80% 70%, rgba(16, 185, 129, 0.1) 0%, transparent 40%);
            z-index: -1;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 1rem;
        }
    </style>
</head>

<body>
    <div class="bg-glow"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // API Keys (hardcoded for personal use)
        const GOOGLE_VISION_API_KEY = 'AIzaSyDp5v_RuQZsNlrqJOKJ1TgAZq2n3GZ8nBg';
        const GOOGLE_DRIVE_CLIENT_ID = '989864367677-fcll4q385kai03cj1hkhaa852i5rdhis.apps.googleusercontent.com';

        // Smart OCR Parsing Logic
        // Precompiled regex patterns (created once, reused for all parses)
        const COMPANY_END_WORDS = ['inc', 'inc.', 'corp', 'corp.', 'corporation', 'llc', 'ltd', 'ltd.', 'co.', 'company'];
        const COMPANY_SUFFIX_END_REGEX = new RegExp(`\\b(${COMPANY_END_WORDS.map(s => s.replace('.', '\\.')).join('|')})$`, 'i');
        const COMPANY_SUFFIX_WORD_REGEX = new RegExp(`\\b(${COMPANY_END_WORDS.map(s => s.replace('.', '\\.')).join('|')})\\b`, 'i');
        const STRONG_COMPANY_SUFFIXES = ['inc', 'inc.', 'corp', 'corp.', 'corporation', 'llc', 'ltd', 'ltd.'];
        const STRONG_SUFFIX_REGEX = new RegExp(`\\b(${STRONG_COMPANY_SUFFIXES.map(s => s.replace('.', '\\.')).join('|')})\\b`, 'i');
        const MERGE_ADDRESS_KW = ['street', 'st.', 'avenue', 'ave', 'road', 'rd', 'floor', 'flr', 'suite', 'unit', 'building', 'bldg', 'city', 'barangay', 'brgy'];
        const PHONE_REGEX = /^\+?\d[\d\s().-]{6,}$/;
        const HAS_LETTERS_REGEX = /[A-Za-z]/;

        // Professional suffixes pattern
        const PROFESSIONAL_SUFFIXES = ['ree', 'pee', 'rme', 'pme', 'cpa', 'cma', 'cfa', 'md', 'm\\.d\\.', 'do', 'd\\.o\\.', 'rn', 'r\\.n\\.', 'bsn', 'jd', 'j\\.d\\.', 'esq', 'esq\\.', 'atty', 'atty\\.', 'phd', 'ph\\.d\\.', 'edd', 'ed\\.d\\.', 'mba', 'm\\.b\\.a\\.', 'ms', 'm\\.s\\.', 'ma', 'm\\.a\\.', 'pe', 'p\\.e\\.', 'se', 's\\.e\\.', 'prc', 'lic\\.', 'certified'];
        const PROFESSIONAL_SUFFIX_REGEX = new RegExp(`[,\\s](${PROFESSIONAL_SUFFIXES.join('|')})$|[,\\s](${PROFESSIONAL_SUFFIXES.join('|')})[,\\s]`, 'i');

        // Title keywords pattern
        const TITLE_KEYWORDS = ['ceo', 'cto', 'cfo', 'coo', 'president', 'vice president', 'vp', 'director', 'manager', 'supervisor', 'lead', 'engineer', 'developer', 'designer', 'analyst', 'consultant', 'sales', 'marketing', 'executive', 'officer', 'associate', 'specialist', 'coordinator', 'administrator', 'assistant', 'founder', 'partner', 'owner', 'chairman', 'secretary', 'accountant', 'attorney', 'lawyer', 'doctor', 'nurse', 'representative', 'agent', 'broker', 'realtor', 'architect', 'account manager', 'project manager', 'general manager'];
        const TITLE_KEYWORD_REGEX = new RegExp(`\\b(${TITLE_KEYWORDS.join('|')})\\b`, 'i');

        const parseBusinessCard = (text) => {
            const normalizedText = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            let lines = normalizedText.split('\n').map(l => l.trim()).filter(l => l.length > 0);

            // PRE-PROCESS: Merge fragmented company names
            // Handles: "BUILDERS,\nINC." | "Google\nLLC" | "Hedgefund\nCorporation Inc"

            // Helper: Check if line is a valid company name fragment
            const isValidFragment = (line) => {
                const lower = line.toLowerCase();
                return HAS_LETTERS_REGEX.test(line) &&
                       !line.includes('@') &&
                       !PHONE_REGEX.test(line) &&
                       !MERGE_ADDRESS_KW.some(kw => lower.includes(kw)) &&
                       line.length < 50;
            };

            // Helper: Check if line ends with a company suffix (uses precompiled regex)
            const endsWithSuffix = (line) => COMPANY_SUFFIX_END_REGEX.test(line.toLowerCase());

            // Helper: Check if line IS exactly a suffix
            const isExactSuffix = (line) => {
                const lower = line.toLowerCase().trim();
                return COMPANY_END_WORDS.some(suf => lower === suf || lower === suf.replace('.', ''));
            };

            // Helper: Extend merge backwards for ALL CAPS single words
            const extendBackwards = (startIdx, lines) => {
                while (startIdx > 0) {
                    const prev = lines[startIdx - 1];
                    const isAllCaps = prev === prev.toUpperCase() && /[A-Z]/.test(prev);
                    const isSingleWord = prev.split(/\s+/).length === 1;
                    if (isAllCaps && isSingleWord && !prev.includes('@') && !/\d{3}/.test(prev) && !endsWithSuffix(prev)) {
                        startIdx--;
                    } else break;
                }
                return startIdx;
            };

            // Identify line types
            const suffixLines = [];      // Lines that ARE just a suffix
            const suffixEndLines = [];   // Lines that END with a suffix
            const commaLines = [];       // ALL CAPS lines ending with comma

            lines.forEach((line, idx) => {
                const isAllCaps = line === line.toUpperCase() && /[A-Z]/.test(line);
                if (isExactSuffix(line)) suffixLines.push(idx);
                else if (endsWithSuffix(line)) suffixEndLines.push(idx);
                if (isAllCaps && line.endsWith(',')) commaLines.push(idx);
            });

            // Build merge map
            const mergeMap = new Map();
            const skipIndices = new Set();

            const addMerge = (start, end) => {
                mergeMap.set(start, end);
                for (let m = start; m <= end; m++) skipIndices.add(m);
            };

            // Process standalone suffix lines (e.g., "LLC")
            suffixLines.forEach(suffixIdx => {
                if (skipIndices.has(suffixIdx)) return;

                // Try 1: Look for comma-ending line within 3 lines back
                for (let k = suffixIdx - 1; k >= Math.max(0, suffixIdx - 3); k--) {
                    if (commaLines.includes(k)) {
                        addMerge(extendBackwards(k, lines), suffixIdx);
                        return;
                    }
                }

                // Try 2: Check immediate previous line
                if (suffixIdx > 0 && isValidFragment(lines[suffixIdx - 1]) && !isExactSuffix(lines[suffixIdx - 1])) {
                    addMerge(extendBackwards(suffixIdx - 1, lines), suffixIdx);
                }
            });

            // Process lines ending with suffix (e.g., "Corporation Inc")
            suffixEndLines.forEach(idx => {
                if (skipIndices.has(idx) || idx === 0) return;
                if (isValidFragment(lines[idx - 1]) && !endsWithSuffix(lines[idx - 1])) {
                    addMerge(extendBackwards(idx - 1, lines), idx);
                }
            });

            // Build merged lines
            const mergedLines = [];
            let i = 0;
            while (i < lines.length) {
                if (mergeMap.has(i)) {
                    const endIdx = mergeMap.get(i);
                    // Merge all lines in range, handling comma lines specially
                    let merged = lines[i];
                    const commaIdx = commaLines.find(c => c > i && c <= endIdx);
                    if (commaIdx !== undefined && commaIdx !== i) merged += ' ' + lines[commaIdx];
                    if (!merged.toLowerCase().includes(lines[endIdx].toLowerCase())) {
                        merged += ' ' + lines[endIdx];
                    }
                    mergedLines.push(merged.replace(/\s+/g, ' ').trim());
                    // Add non-merge lines in range (e.g., "ELECTRICAL CONTRACTOR")
                    for (let m = i + 1; m < endIdx; m++) {
                        if (m !== commaIdx) mergedLines.push(lines[m]);
                    }
                    i = endIdx + 1;
                } else if (!skipIndices.has(i)) {
                    mergedLines.push(lines[i]);
                    i++;
                } else i++;
            }

            lines = mergedLines;
            if (mergeMap.size > 0) {
                console.log('[Parser] Merged company names:', Array.from(mergeMap.entries()).map(([s, e]) => `${s}-${e}`));
            }

            // Extract emails - must have proper format with domain
            const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/gi;
            let emails = (normalizedText.match(emailRegex) || []).filter(e => e.length > 5 && e.includes('.'));

            // Sort emails: prefer personal emails (with person names) over generic company emails
            const genericEmailPrefixes = ['info', 'sales', 'support', 'contact', 'admin', 'hello', 'office', 'enquiry', 'inquiry', 'marketing'];
            emails.sort((a, b) => {
                const aPrefix = a.split('@')[0].toLowerCase();
                const bPrefix = b.split('@')[0].toLowerCase();
                const aIsGeneric = genericEmailPrefixes.some(p => aPrefix.includes(p));
                const bIsGeneric = genericEmailPrefixes.some(p => bPrefix.includes(p));
                if (aIsGeneric && !bIsGeneric) return 1;  // b comes first (personal email)
                if (!aIsGeneric && bIsGeneric) return -1; // a comes first (personal email)
                return 0;
            });

            // Extract phone numbers - need at least 7 digits total, handle various formats
            // Look for lines with "Mobile", "Tel", "Phone" or standalone number patterns
            const phonePatterns = [];

            // Pattern 1: Numbers with Mobile/Tel/Phone prefix
            const labeledPhoneRegex = /(?:mobile|tel|phone|fax|cell)[\s.:]*(?:no)?[\s.:]*([+\d\s()/-]{7,})/gi;
            let match;
            while ((match = labeledPhoneRegex.exec(normalizedText)) !== null) {
                phonePatterns.push(match[1]);
            }

            // Pattern 2: Standalone phone numbers (7+ digits with optional formatting)
            // Supports: (123) 456-7890, 123.456.7890, 123-456-7890, +63 928 520 1886, (0928) 520-1886, etc.
            const standalonePhoneRegex = /(?:^|[\s:])(\+?63[\s.-]?\d{3}[\s.-]?\d{3}[\s.-]?\d{4}|\+?63[\s.-]?\d{10}|\(?\d{3,4}\)?[\s.-]?\d{3,4}[\s.-]?\d{4}|0\d{3}[\s.-]?\d{3}[\s.-]?\d{4}|0\d{3}[\s.-]?\d{7}|\d{3,4}[\s.-]\d{3,4}[\s.-]\d{3,4})/gm;
            while ((match = standalonePhoneRegex.exec(normalizedText)) !== null) {
                phonePatterns.push(match[1]);
            }

            // Clean and deduplicate phones
            const phones = [...new Set(phonePatterns
                .map(p => p.replace(/[\s()-]/g, '').replace(/^[:.]/, '').trim())
                .filter(p => {
                    const digitsOnly = p.replace(/\D/g, '');
                    return digitsOnly.length >= 7 && digitsOnly.length <= 15;
                })
            )];

            // Extract websites
            const websiteRegex = /(?:https?:\/\/)?(?:www\.)?[a-zA-Z0-9-]+\.[a-zA-Z]{2,}(?:\/\S*)?/gi;
            const websites = (normalizedText.match(websiteRegex) || []).filter(w => !w.includes('@'));

            // Common company suffixes
            const companySuffixes = [
                'inc', 'inc.', 'incorporated', 'corp', 'corp.', 'corporation',
                'llc', 'l.l.c.', 'ltd', 'ltd.', 'limited', 'co', 'co.',
                'company', 'enterprises', 'solutions', 'services', 'group',
                'technologies', 'tech', 'systems', 'industries', 'international',
                'holdings', 'partners', 'associates', 'consulting', 'agency',
                'engineering', 'construction', 'trading', 'realty', 'properties'
            ];

            // Address keywords
            const addressKeywords = [
                'street', 'st.', 'avenue', 'ave', 'ave.', 'road', 'rd', 'rd.',
                'boulevard', 'blvd', 'drive', 'dr.', 'lane', 'ln',
                'floor', 'flr', 'suite', 'ste', 'unit', 'building', 'bldg',
                'phase', 'block', 'blk', 'lot', 'village', 'subdivision',
                'city', 'province', 'barangay', 'brgy', 'metro manila',
                'makati', 'quezon', 'manila', 'pasig', 'taguig', 'cavite', 'laguna', 'bacoor',
                'head office', 'main office', 'branch office', 'place', 'tower', 'center', 'centre'
            ];

            // Categorize each line
            const categorized = {
                name: null,
                position: null,
                company: null,
                phones: phones, // Store ALL phone numbers
                phone: phones[0] || '', // Primary phone for backward compatibility
                email: emails[0] || '',
                website: websites[0] || '',
                address: null,
                otherLines: []
            };

            // Lines that contain extracted data (to exclude from other processing)
            const usedLines = new Set();

            // Mark lines containing emails, phones, websites, or label-only lines
            lines.forEach((line, idx) => {
                const lineLower = line.toLowerCase();
                // Mark email lines
                if (emails.some(e => lineLower.includes(e.toLowerCase()))) usedLines.add(idx);
                // Mark phone lines - check if line has phone numbers or is a phone label
                const hasPhoneDigits = phones.some(p => {
                    const last7 = p.slice(-7);
                    return line.replace(/[\s-]/g, '').includes(last7);
                });
                if (hasPhoneDigits || /^(mobile|tel|phone|fax|cell)[\s.:]*no?\.?$/i.test(line.trim())) {
                    usedLines.add(idx);
                }
                // Mark website lines
                if (websites.some(w => lineLower.includes(w.toLowerCase()))) usedLines.add(idx);
                // Mark label-only lines like "Email", "Tel. No.", etc.
                if (/^(email|e-mail|tel|telephone|mobile|phone|fax|address|website|web)[\s.:]*$/i.test(line.trim())) {
                    usedLines.add(idx);
                }
                // Mark lines that are just colons or punctuation with short text
                if (/^[:.\s]*$/.test(line) || line.length <= 2) {
                    usedLines.add(idx);
                }
            });

            // STEP 1: Find name with professional suffix (highest priority - these are definitely names)
            lines.forEach((line, idx) => {
                if (usedLines.has(idx) || categorized.name) return;
                const lineLower = line.toLowerCase();

                // Use precompiled regex for professional suffix check
                if (PROFESSIONAL_SUFFIX_REGEX.test(lineLower)) {
                    categorized.name = line;
                    usedLines.add(idx);
                }
            });

            // STEP 2: Find position/title line FIRST (helps identify name)
            // Collect ALL potential position lines with scores, then pick the best one
            const positionCandidates = [];

            lines.forEach((line, idx) => {
                if (usedLines.has(idx)) return;
                const lineLower = line.toLowerCase();

                // Use precompiled regex for title keyword check
                if (!TITLE_KEYWORD_REGEX.test(lineLower)) return;

                // Find which keywords matched for scoring
                const matchedKeywords = TITLE_KEYWORDS.filter(kw => lineLower.includes(kw));

                // Don't use as title if it looks like a company name with strong suffix
                if (STRONG_SUFFIX_REGEX.test(lineLower)) return;

                // Don't use as title if it looks like an address
                const addressIndicators = ['building', 'bldg', 'floor', 'flr', 'street', 'st.', 'avenue', 'ave', 'road', 'rd', 'place', 'tower', 'unit', 'suite', 'block', 'blk', 'lot', 'phase', 'head office', 'main office', 'branch office'];
                const looksLikeAddress = addressIndicators.some(ind => lineLower.includes(ind));
                if (looksLikeAddress) {
                    console.log(`[Parser] Skipping "${line}" - looks like address`);
                    return;
                }

                // Calculate a score for this position candidate
                let score = 10;

                // PENALTY: Lines that look like service/feature lists (dot-separated items)
                // e.g., ".SALES .SERVICES" or "ENGINEERING . MAINTENANCE"
                const dotSeparatedItems = line.split(/[.•·]/).filter(s => s.trim().length > 0);
                if (dotSeparatedItems.length >= 2) {
                    // Looks like a bullet list - big penalty
                    score -= 50;
                }

                // PENALTY: All caps service descriptors (like "SALES" alone or in a list)
                const serviceWords = ['sales', 'services', 'maintenance', 'engineering', 'construction', 'consulting', 'trading'];
                const words = lineLower.split(/\s+/);
                const serviceWordCount = words.filter(w => serviceWords.includes(w.replace(/[^a-z]/g, ''))).length;
                if (serviceWordCount >= 2) {
                    score -= 40; // Multiple service words = probably a service list
                }

                // BONUS: Multi-word titles like "account manager", "project manager"
                if (matchedKeywords.some(k => k.includes(' '))) {
                    score += 30;
                }

                // BONUS: Line is short and focused (typical job title length)
                if (line.length < 30 && words.length <= 4) {
                    score += 20;
                }

                // BONUS: Title-case or mixed case (not ALL CAPS service lists)
                if (line !== line.toUpperCase() && line !== line.toLowerCase()) {
                    score += 10;
                }

                console.log(`[Parser] "${line}" score: ${score}`);

                positionCandidates.push({ line, idx, score, keywords: matchedKeywords });
            });

            // Pick the best position candidate
            let positionIdx = -1;
            if (positionCandidates.length > 0) {
                positionCandidates.sort((a, b) => b.score - a.score);
                // Only use if score is positive (not a service list)
                if (positionCandidates[0].score > 0) {
                    categorized.position = positionCandidates[0].line;
                    positionIdx = positionCandidates[0].idx;
                    usedLines.add(positionIdx);
                }
            }

            // STEP 3: If we found a position, the line BEFORE it is likely the person's name
            // (unless we already found a name with professional suffix)
            if (!categorized.name && positionIdx > 0) {
                // Look at the line immediately before the position
                for (let checkIdx = positionIdx - 1; checkIdx >= 0; checkIdx--) {
                    if (usedLines.has(checkIdx)) continue;

                    const candidateLine = lines[checkIdx];
                    const candidateLower = candidateLine.toLowerCase();
                    const words = candidateLine.split(/\s+/);

                    // NEVER use a line with company suffix as a name (use precompiled regex)
                    if (STRONG_SUFFIX_REGEX.test(candidateLower)) continue;

                    // Skip lines that look like service/feature lists (dot-separated)
                    const dotItems = candidateLine.split(/[.•·]/).filter(s => s.trim().length > 0);
                    if (dotItems.length >= 2) continue;

                    // Skip lines that start with dots/bullets (service list items)
                    if (/^[.•·\s]/.test(candidateLine)) continue;

                    // Check if this looks like a person's name (not a company descriptor)
                    const looksLikeName =
                        words.length >= 2 &&
                        words.length <= 4 &&
                        !candidateLine.includes('@') &&
                        !/\d{3}/.test(candidateLine) &&
                        // Exclude common service/business descriptors
                        !['event', 'management', 'services', 'solutions', 'consulting', 'agency', 'industrial', 'controls', 'systems', 'engineering', 'maintenance', 'sales', 'trading', 'construction'].some(w => candidateLower.includes(w));

                    if (looksLikeName) {
                        categorized.name = candidateLine;
                        usedLines.add(checkIdx);
                        break;
                    }
                }
            }

            // STEP 4: Find address line
            lines.forEach((line, idx) => {
                if (usedLines.has(idx)) return;
                const lineLower = line.toLowerCase();

                // Skip lines that look like company names (use precompiled regex)
                if (STRONG_SUFFIX_REGEX.test(lineLower)) return;

                const hasAddressKeyword = addressKeywords.some(keyword => lineLower.includes(keyword));
                const hasZipCode = /\b\d{4,6}\b/.test(line);
                const hasPhaseBlock = /phase|block|lot|blk/i.test(line);
                const hasMultipleCommas = (line.match(/,/g) || []).length >= 2;

                if ((hasAddressKeyword || hasPhaseBlock || (hasZipCode && hasMultipleCommas)) && !categorized.address) {
                    categorized.address = line;
                    usedLines.add(idx);
                }
            });

            // STEP 5: Find company line - collect candidates and pick the best one
            const companyStrongIndicators = ['inc', 'inc.', 'corp', 'corporation', 'llc', 'ltd', 'enterprises', 'industries', 'international', 'construction', 'builders'];
            const companyCandidates = [];

            lines.forEach((line, idx) => {
                if (usedLines.has(idx)) return;
                const lineLower = line.toLowerCase();

                // Use precompiled regex for company suffix check
                if (COMPANY_SUFFIX_WORD_REGEX.test(lineLower)) {
                    // Score the company candidate
                    let score = line.length;

                    // Strong bonus for definite company indicators (INC, CORP, LLC, etc.)
                    if (companyStrongIndicators.some(ind => lineLower.includes(ind))) {
                        score += 100;
                    }

                    // Bonus for ALL CAPS
                    if (line === line.toUpperCase() && /[A-Z]/.test(line)) {
                        score += 20;
                    }

                    // PENALTY: If it looks like a person's name (2 words, both capitalized proper names)
                    const words = line.split(/\s+/);
                    if (words.length === 2 && words.every(w => /^[A-Z][a-z]*$/.test(w) || /^[A-Z]+$/.test(w))) {
                        // Could be a person's name like "ROBIN REYES" - reduce score unless it has strong company indicators
                        if (!companyStrongIndicators.some(ind => lineLower.includes(ind))) {
                            score -= 50;
                        }
                    }

                    companyCandidates.push({ line, idx, score });
                }
            });

            // Pick the best company candidate
            if (companyCandidates.length > 0) {
                companyCandidates.sort((a, b) => b.score - a.score);
                // Only use if score is positive (not penalized too much)
                if (companyCandidates[0].score > 0) {
                    categorized.company = companyCandidates[0].line;
                    usedLines.add(companyCandidates[0].idx);
                }
            }

            // If no name with professional suffix, find name from remaining lines
            if (!categorized.name) {
                lines.forEach((line, idx) => {
                    if (usedLines.has(idx) || categorized.name) return;

                    const lineLower = line.toLowerCase();
                    const words = line.split(/[\s,]+/).filter(w => w.length > 0);

                    // NEVER use lines with company suffixes as names (use precompiled regex)
                    if (STRONG_SUFFIX_REGEX.test(lineLower)) return;

                    // Name patterns: 2-5 words, mostly letters, may have comma for suffix
                    const isLikelyName =
                        words.length >= 2 &&
                        words.length <= 5 &&
                        !line.includes('@') &&
                        !/\d{3}/.test(line) && // No long number sequences
                        line.length < 40 &&
                        words.every(w => /^[A-Za-z'.,-]+$/.test(w));

                    if (isLikelyName) {
                        categorized.name = line;
                        usedLines.add(idx);
                    }
                });
            }

            // If no name found, use first unused line that looks name-like
            if (!categorized.name) {
                for (let idx = 0; idx < lines.length; idx++) {
                    if (usedLines.has(idx)) continue;
                    const line = lines[idx];
                    const lineLower = line.toLowerCase();
                    const words = line.split(/\s+/);

                    // NEVER use lines with company suffixes as names (use precompiled regex)
                    if (STRONG_SUFFIX_REGEX.test(lineLower)) continue;

                    // Simple heuristic: first line with 2-4 words, no numbers, no special chars
                    if (words.length >= 2 && words.length <= 4 && !/\d/.test(line) && line.length < 40) {
                        categorized.name = line;
                        usedLines.add(idx);
                        break;
                    }
                }
            }

            // If still no name, just use first unused line (but still avoid company names)
            if (!categorized.name) {
                const firstUnused = lines.findIndex((line, idx) => {
                    if (usedLines.has(idx)) return false;
                    // Use precompiled regex
                    return !STRONG_SUFFIX_REGEX.test(line.toLowerCase());
                });
                if (firstUnused !== -1) {
                    categorized.name = lines[firstUnused];
                    usedLines.add(firstUnused);
                }
            }

            // If no company found, try to find one from remaining lines
            if (!categorized.company) {
                const remainingLines = lines.filter((_, idx) => !usedLines.has(idx));
                // Company names are often in ALL CAPS
                const possibleCompany = remainingLines.find(line => {
                    const isAllCaps = line === line.toUpperCase() && line.length > 3 && /[A-Z]/.test(line);
                    return isAllCaps && !/\d{4}/.test(line); // Not a phone or zip
                });
                if (possibleCompany) {
                    categorized.company = possibleCompany;
                    usedLines.add(lines.indexOf(possibleCompany));
                }
            }

            // Collect remaining lines as potential address
            const remainingLines = lines.filter((_, idx) => !usedLines.has(idx));
            if (!categorized.address && remainingLines.length > 0) {
                // Join remaining address-like lines
                const addressLines = remainingLines.filter(line =>
                    /\d/.test(line) || // Has numbers
                    addressKeywords.some(kw => line.toLowerCase().includes(kw))
                );
                if (addressLines.length > 0) {
                    categorized.address = addressLines.slice(0, 2).join(', ');
                }
            }

            // Format multiple phones for display
            const phoneDisplay = phones.length > 1
                ? phones.join(' / ')
                : phones[0] || '';

            const result = {
                name: categorized.name || 'Unknown',
                position: categorized.position || '',
                company: categorized.company || '',
                phone: phoneDisplay, // All phones joined
                phones: phones, // Array of all phones
                email: categorized.email,
                website: categorized.website,
                address: categorized.address || '',
                notes: '',
                rawText: text // Keep for AI validation
            };

            return result;
        };

        // Validate/correct parsing with Gemini AI
        const validateWithGemini = async (rawText, parsed) => {
            console.log('[Gemini] Enhancing parsing to 99% accuracy...');

            try {
                const prompt = `You are an expert business card data curator. Your goal is to polish OCR-extracted contact information to 99% accuracy.

RAW OCR TEXT:
${rawText}

INITIAL PARSED DATA (needs refinement):
Name: ${parsed.name}
Position: ${parsed.position}
Company: ${parsed.company}
Phone: ${parsed.phone}
Email: ${parsed.email}
Address: ${parsed.address}

YOUR TASK: Improve accuracy to 99% by:
1. **Fix spacing**: "JohnSmith" → "John Smith", "Acme Inc" → "Acme Inc."
2. **Proper capitalization**: "ACME INC" → "Acme Inc.", "john smith" → "John Smith"
3. **Validate name/company**: Person names are 2-4 words. Companies have Inc/Corp/LLC/Solutions/Services
4. **Standardize phone**: Use consistent format (keep country code if present)
5. **Clean artifacts**: Remove OCR errors like extra spaces, weird characters
6. **Infer missing data**: If position is missing but context suggests a role, add it
7. **Format company properly**: "ACME, INC." → "Acme, Inc."
8. **CRITICAL - Merge fragmented company names**: OCR often splits company names across lines. Look in raw text for patterns like:
   - "Google" on one line, "LLC" on another → combine to "Google LLC"
   - "Acme" then "Corporation" → "Acme Corporation"
   - "Hedgefund" then "Corporation Inc" → "Hedgefund Corporation Inc"
   - Company name in logo text that appears separately from suffix
   If the parsed company is ONLY a suffix (LLC, Inc, Corp, etc.), missing a word, or incomplete, search the RAW text for the full company name and combine ALL the parts.

Return ONLY valid JSON (no markdown formatting):
{
  "name": "Properly Capitalized Name",
  "position": "Job Title",
  "company": "Company Name Inc.",
  "phone": "formatted phone",
  "email": "email@domain.com",
  "address": "cleaned address"
}

CRITICAL: Ensure name is a person, company has business indicators. If you swap them, verify it makes sense.`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GOOGLE_VISION_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: prompt }]
                        }],
                        generationConfig: {
                            temperature: 0.1,
                            maxOutputTokens: 500
                        }
                    })
                });

                const data = await response.json();

                if (data.error) {
                    console.error('[Gemini] API error:', data.error);
                    return { ...parsed, _aiValidated: false, _aiError: data.error.message || 'API error' };
                }

                // Safe navigation with null checks
                const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) {
                    console.warn('[Gemini] Empty or malformed response, using original parsing');
                    return { ...parsed, _aiValidated: false, _aiError: 'Empty response from AI' };
                }

                // Extract JSON from response (handle markdown code blocks)
                let jsonText = text.trim();
                if (jsonText.startsWith('```')) {
                    jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                }

                const corrected = JSON.parse(jsonText);

                console.log('[Gemini] Enhanced:', {
                    before: { name: parsed.name, company: parsed.company },
                    after: { name: corrected.name, company: corrected.company }
                });

                // Merge corrected data with original (keep phones array)
                return {
                    ...parsed,
                    name: corrected.name || parsed.name,
                    position: corrected.position || parsed.position,
                    company: corrected.company || parsed.company,
                    phone: corrected.phone || parsed.phone,
                    email: corrected.email || parsed.email,
                    address: corrected.address || parsed.address,
                    _aiValidated: true
                };

            } catch (error) {
                console.error('[Gemini] Validation error:', error);
                return { ...parsed, _aiValidated: false, _aiError: error.message };
            }
        };

        // Parse with optional AI validation
        const parseWithValidation = async (text, useAI = true) => {
            const parsed = parseBusinessCard(text);

            if (!useAI) {
                console.log('[Parser] AI validation disabled, using rule-based parsing only');
                return { ...parsed, _aiValidated: false, _aiError: 'AI disabled' };
            }

            // Enhance with AI for 99% accuracy
            // Uses Gemini 1.5 Flash (free tier: 1,500 requests/day)
            return await validateWithGemini(text, parsed);
        };

        // Google Vision OCR
        const googleVisionOCR = async (imageSrc, apiKey) => {
            console.log('[Google Vision] Starting OCR...');
            const base64Image = imageSrc.replace(/^data:image\/\w+;base64,/, '');

            const response = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    requests: [{
                        image: { content: base64Image },
                        features: [{ type: 'TEXT_DETECTION' }]
                    }]
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error?.message || `API error: ${response.status}`);
            }

            const data = await response.json();
            console.log('[Google Vision] Response received');

            if (data.responses[0]?.error) {
                throw new Error(data.responses[0].error.message);
            }

            const text = data.responses[0]?.fullTextAnnotation?.text || '';
            return { text, confidence: text ? 90 : 0 };
        };

        // Convert blob URL or File to base64 data URL
        const toBase64 = async (input) => {
            // If it's already a data URL, return as-is
            if (typeof input === 'string' && input.startsWith('data:')) {
                return input;
            }

            // If it's a blob URL, fetch and convert
            if (typeof input === 'string' && input.startsWith('blob:')) {
                const response = await fetch(input);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            // If it's a File or Blob object
            if (input instanceof Blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(input);
                });
            }

            return input;
        };

        // Preprocess image for better OCR (grayscale, contrast, threshold)
        const preprocessImage = async (imageSrc) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Use larger canvas for better quality
                    const scale = Math.max(1, 1500 / Math.max(img.width, img.height));
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;

                    // Draw original image
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    // Get image data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;

                    // Convert to grayscale and increase contrast
                    for (let i = 0; i < data.length; i += 4) {
                        // Grayscale
                        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];

                        // Increase contrast
                        const contrast = 1.5;
                        const factor = (259 * (contrast * 100 + 255)) / (255 * (259 - contrast * 100));
                        let newGray = factor * (gray - 128) + 128;

                        // Clamp values
                        newGray = Math.max(0, Math.min(255, newGray));

                        // Apply threshold for cleaner text (binarization)
                        const threshold = 140;
                        const finalValue = newGray > threshold ? 255 : 0;

                        data[i] = finalValue;     // R
                        data[i + 1] = finalValue; // G
                        data[i + 2] = finalValue; // B
                        // Alpha stays the same
                    }

                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = () => resolve(imageSrc); // Fallback to original
                img.src = imageSrc;
            });
        };

        // Tesseract OCR with preprocessing
        const tesseractOCR = async (imageSrc, onProgress) => {
            console.log('[Tesseract] Starting OCR...');

            // Preprocess image for better recognition
            if (onProgress) onProgress('Preprocessing image...', 10);
            const processedImage = await preprocessImage(imageSrc);
            console.log('[Tesseract] Image preprocessed');

            const worker = await Tesseract.createWorker('eng', 1, {
                logger: m => {
                    console.log('[Tesseract]', m.status, m.progress ? Math.round(m.progress * 100) + '%' : '');
                    if (onProgress && m.progress) onProgress(m.status, Math.round(m.progress * 100));
                }
            });

            const result = await worker.recognize(processedImage);
            await worker.terminate();

            console.log('[Tesseract] Complete, confidence:', result.data.confidence);
            console.log('[Tesseract] Raw text:', result.data.text);
            return { text: result.data.text, confidence: result.data.confidence };
        };

        const App = () => {
            // Core state
            const [view, setView] = useState('home');
            const [contacts, setContacts] = useState([]);
            const [capturedImage, setCapturedImage] = useState(null);
            const [ocrResult, setOcrResult] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);

            // Settings state
            // API keys are defined globally (see top of file)
            const googleApiKey = GOOGLE_VISION_API_KEY;
            const [ocrEngine, setOcrEngine] = useState(localStorage.getItem('ocr_engine') || 'tesseract');
            const [aiValidation, setAiValidation] = useState(localStorage.getItem('ai_validation') !== 'false'); // Default ON

            // Google Drive sync state
            const driveClientId = GOOGLE_DRIVE_CLIENT_ID;
            const [driveConnected, setDriveConnected] = useState(false);
            const [driveUser, setDriveUser] = useState(null);
            const [driveSyncing, setDriveSyncing] = useState(false);
            const [driveFileId, setDriveFileId] = useState(localStorage.getItem('drive_file_id') || null);
            const [lastSyncTime, setLastSyncTime] = useState(localStorage.getItem('last_sync_time') || null);

            // Bulk upload state
            const [bulkQueue, setBulkQueue] = useState([]);
            const [bulkResults, setBulkResults] = useState([]);

            // Manual entry state
            const [manualEntry, setManualEntry] = useState({
                name: '', position: '', company: '', phone: '', email: '', address: '', notes: ''
            });

            // Error and status state
            const [error, setError] = useState(null);
            const [statusMessage, setStatusMessage] = useState('');
            const [progress, setProgress] = useState(0);

            // Refs
            const videoRef = useRef(null);
            const fileInputRef = useRef(null);

            // Load contacts from localStorage
            useEffect(() => {
                const saved = localStorage.getItem('demo_contacts');
                if (saved) setContacts(JSON.parse(saved));
            }, []);

            // Google Drive API Configuration
            const DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.appdata';
            const DRIVE_FILE_NAME = 'curator-contacts.json';

            // Initialize Google API client
            const initGoogleDrive = async () => {
                if (!driveClientId) return false;

                return new Promise((resolve) => {
                    if (window.gapi) {
                        window.gapi.load('client', async () => {
                            try {
                                await window.gapi.client.init({
                                    discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
                                });
                                console.log('[Drive] Google API client initialized');
                                resolve(true);
                            } catch (err) {
                                console.error('[Drive] Init error:', err);
                                resolve(false);
                            }
                        });
                    } else {
                        resolve(false);
                    }
                });
            };

            // Google Sign-In
            const connectGoogleDrive = async () => {
                if (!driveClientId) {
                    setError('Please enter your Google Client ID first');
                    return;
                }

                try {
                    await initGoogleDrive();

                    const tokenClient = window.google.accounts.oauth2.initTokenClient({
                        client_id: driveClientId,
                        scope: DRIVE_SCOPES,
                        callback: async (response) => {
                            if (response.access_token) {
                                window.gapi.client.setToken({ access_token: response.access_token });
                                setDriveConnected(true);

                                // Get user info
                                try {
                                    const userInfo = await window.gapi.client.request({
                                        path: 'https://www.googleapis.com/oauth2/v2/userinfo'
                                    });
                                    setDriveUser(userInfo.result);
                                    console.log('[Drive] Connected as:', userInfo.result.email);
                                } catch (e) {
                                    console.log('[Drive] Could not get user info');
                                }

                                // Load contacts from Drive
                                await loadFromDrive();
                            }
                        },
                        error_callback: (err) => {
                            console.error('[Drive] Auth error:', err);
                            setError('Google sign-in failed: ' + (err.message || 'Unknown error'));
                        }
                    });

                    tokenClient.requestAccessToken({ prompt: 'consent' });
                } catch (err) {
                    console.error('[Drive] Connect error:', err);
                    setError('Failed to connect: ' + err.message);
                }
            };

            // Disconnect Google Drive
            const disconnectGoogleDrive = () => {
                if (window.google && window.google.accounts) {
                    window.google.accounts.oauth2.revoke(window.gapi.client.getToken()?.access_token, () => {
                        console.log('[Drive] Token revoked');
                    });
                }
                window.gapi?.client?.setToken(null);
                setDriveConnected(false);
                setDriveUser(null);
                setDriveFileId(null);
                localStorage.removeItem('drive_file_id');
                localStorage.removeItem('last_sync_time');
                setLastSyncTime(null);
            };

            // Find or create the contacts file in Drive
            const findOrCreateDriveFile = async () => {
                try {
                    // Search for existing file in appDataFolder
                    const searchResponse = await window.gapi.client.drive.files.list({
                        spaces: 'appDataFolder',
                        q: `name='${DRIVE_FILE_NAME}'`,
                        fields: 'files(id, name, modifiedTime)'
                    });

                    const files = searchResponse.result.files;

                    if (files && files.length > 0) {
                        console.log('[Drive] Found existing file:', files[0].id);
                        return files[0].id;
                    }

                    // Create new file
                    const createResponse = await window.gapi.client.drive.files.create({
                        resource: {
                            name: DRIVE_FILE_NAME,
                            parents: ['appDataFolder'],
                            mimeType: 'application/json'
                        },
                        fields: 'id'
                    });

                    console.log('[Drive] Created new file:', createResponse.result.id);
                    return createResponse.result.id;
                } catch (err) {
                    console.error('[Drive] File operation error:', err);
                    throw err;
                }
            };

            // Save contacts to Google Drive
            const saveToDrive = async (contactsToSave) => {
                if (!driveConnected) return;

                setDriveSyncing(true);
                try {
                    const fileId = driveFileId || await findOrCreateDriveFile();

                    if (!driveFileId) {
                        setDriveFileId(fileId);
                        localStorage.setItem('drive_file_id', fileId);
                    }

                    // Update file content
                    const content = JSON.stringify({
                        version: 1,
                        contacts: contactsToSave,
                        lastModified: new Date().toISOString()
                    });

                    await window.gapi.client.request({
                        path: `/upload/drive/v3/files/${fileId}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        headers: { 'Content-Type': 'application/json' },
                        body: content
                    });

                    const syncTime = new Date().toISOString();
                    setLastSyncTime(syncTime);
                    localStorage.setItem('last_sync_time', syncTime);
                    console.log('[Drive] Saved to Drive');
                } catch (err) {
                    console.error('[Drive] Save error:', err);
                    // Don't show error to user for background syncs
                } finally {
                    setDriveSyncing(false);
                }
            };

            // Load contacts from Google Drive
            const loadFromDrive = async () => {
                if (!driveConnected && !window.gapi?.client?.getToken()) return;

                setDriveSyncing(true);
                try {
                    const fileId = driveFileId || await findOrCreateDriveFile();

                    if (!driveFileId) {
                        setDriveFileId(fileId);
                        localStorage.setItem('drive_file_id', fileId);
                    }

                    // Get file content
                    const response = await window.gapi.client.drive.files.get({
                        fileId: fileId,
                        alt: 'media'
                    });

                    if (response.result && response.result.contacts) {
                        const driveContacts = response.result.contacts;
                        console.log('[Drive] Loaded', driveContacts.length, 'contacts from Drive');

                        // Merge: Drive contacts take priority, but keep local-only contacts
                        const localContacts = JSON.parse(localStorage.getItem('demo_contacts') || '[]');
                        const driveIds = new Set(driveContacts.map(c => c.id));
                        const localOnly = localContacts.filter(c => !driveIds.has(c.id));

                        const merged = [...driveContacts, ...localOnly];
                        setContacts(merged);
                        localStorage.setItem('demo_contacts', JSON.stringify(merged));

                        // Save merged back to Drive if there were local-only contacts
                        if (localOnly.length > 0) {
                            await saveToDrive(merged);
                        }

                        const syncTime = new Date().toISOString();
                        setLastSyncTime(syncTime);
                        localStorage.setItem('last_sync_time', syncTime);
                    }
                } catch (err) {
                    console.error('[Drive] Load error:', err);
                    // File might be empty or not exist yet, that's OK
                } finally {
                    setDriveSyncing(false);
                }
            };

            // Auto-sync when contacts change
            useEffect(() => {
                if (driveConnected && contacts.length > 0) {
                    // Debounce: wait 2 seconds after last change before syncing
                    const timer = setTimeout(() => {
                        saveToDrive(contacts);
                    }, 2000);
                    return () => clearTimeout(timer);
                }
            }, [contacts, driveConnected]);

            // Save contacts to localStorage (always) when they change
            useEffect(() => {
                if (contacts.length > 0) {
                    localStorage.setItem('demo_contacts', JSON.stringify(contacts));
                }
            }, [contacts]);

            // Icon component
            const SafeIcon = ({ name, className = "" }) => {
                const iconRef = useRef(null);
                useEffect(() => {
                    if (iconRef.current && window.lucide) {
                        iconRef.current.innerHTML = `<i data-lucide="${name}" class="${className}"></i>`;
                        window.lucide.createIcons({ targets: [iconRef.current.firstChild] });
                    }
                }, [name, className]);
                return <span ref={iconRef} style={{ display: 'inline-flex' }}></span>;
            };

            // Camera functions
            const startCamera = async () => {
                setCapturedImage(null);
                setError(null);
                setView('scan');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                    if (videoRef.current) videoRef.current.srcObject = stream;
                } catch (e) {
                    setError("Camera access denied. Please allow camera permissions.");
                    setView('home');
                }
            };

            const capture = () => {
                if (!videoRef.current) return;
                const canvas = document.createElement('canvas');
                canvas.width = videoRef.current.videoWidth || 640;
                canvas.height = videoRef.current.videoHeight || 480;
                const ctx = canvas.getContext('2d');
                if (ctx) ctx.drawImage(videoRef.current, 0, 0);
                setCapturedImage(canvas.toDataURL('image/jpeg'));
                // Safely stop video tracks
                if (videoRef.current.srcObject) {
                    videoRef.current.srcObject.getTracks().forEach(t => t.stop());
                }
            };

            // OCR function
            const runOCR = async () => {
                setError(null);
                setStatusMessage('');
                setProgress(0);

                // Validate settings
                if (ocrEngine === 'google' && !googleApiKey) {
                    setError('Google Vision API key not configured. Go to Settings to add your API key, or switch to Tesseract (local) OCR.');
                    return;
                }

                setIsProcessing(true);

                try {
                    let result;

                    if (ocrEngine === 'google') {
                        setStatusMessage('Sending to Google Cloud Vision...');
                        setProgress(50);
                        result = await googleVisionOCR(capturedImage, googleApiKey);
                    } else {
                        setStatusMessage('Loading Tesseract engine...');
                        result = await tesseractOCR(capturedImage, (status, prog) => {
                            setStatusMessage(status);
                            setProgress(prog);
                        });
                    }

                    setProgress(90);
                    setStatusMessage('Parsing results...');

                    const parsed = await parseWithValidation(result.text, aiValidation);
                    setOcrResult({
                        ...parsed,
                        rawText: result.text,
                        confidence: result.confidence,
                        showRawText: false
                    });

                    setProgress(100);
                    setStatusMessage('Complete!');
                    setView('review');
                } catch (e) {
                    console.error('[OCR Error]', e);
                    setError(`OCR Failed: ${e.message}`);
                } finally {
                    setIsProcessing(false);
                }
            };

            // Save contact
            const saveContact = (contact) => {
                const newContacts = [{ ...contact, id: Date.now(), createdAt: new Date().toISOString() }, ...contacts];
                setContacts(newContacts);
                localStorage.setItem('demo_contacts', JSON.stringify(newContacts));
                setOcrResult(null);
                setCapturedImage(null);
                setView('contacts');
            };

            // File upload
            const handleFileUpload = (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                setBulkQueue(files.map(f => ({
                    id: Math.random().toString(36).substr(2, 9),
                    file: f,
                    preview: URL.createObjectURL(f),
                    status: 'queued'
                })));
                setError(null);
                setView('upload');
            };

            // Bulk processing
            const processBulk = async () => {
                setError(null);

                if (ocrEngine === 'google' && !googleApiKey) {
                    setError('Google Vision API key not configured. Go to Settings to add your API key, or switch to Tesseract (local) OCR.');
                    return;
                }

                setIsProcessing(true);
                setStatusMessage('Starting batch processing...');
                const results = [];

                try {
                    let worker = null;

                    // Create Tesseract worker once for batch
                    if (ocrEngine === 'tesseract') {
                        setStatusMessage('Loading Tesseract engine...');
                        worker = await Tesseract.createWorker('eng', 1, {
                            logger: m => console.log('[Tesseract]', m.status)
                        });
                    }

                    for (let i = 0; i < bulkQueue.length; i++) {
                        const item = bulkQueue[i];
                        setStatusMessage(`Processing ${i + 1} of ${bulkQueue.length}...`);
                        setBulkQueue(prev => prev.map((q, idx) => idx === i ? { ...q, status: 'processing' } : q));

                        try {
                            let result;
                            if (ocrEngine === 'google') {
                                // Convert blob URL to base64 for Google Vision
                                const base64Image = await toBase64(item.preview);
                                result = await googleVisionOCR(base64Image, googleApiKey);
                            } else {
                                const tesseractResult = await worker.recognize(item.preview);
                                result = { text: tesseractResult.data.text, confidence: tesseractResult.data.confidence };
                            }

                            const parsed = await parseWithValidation(result.text, aiValidation);
                            results.push({
                                ...parsed,
                                id: `${Date.now()}-${i}-${Math.random().toString(36).substr(2, 9)}`,
                                image: item.preview,
                                fileName: item.file.name,
                                rawText: result.text,
                                confidence: result.confidence,
                                approved: true,
                                showRawText: false
                            });

                            setBulkQueue(prev => prev.map((q, idx) => idx === i ? { ...q, status: 'completed' } : q));
                        } catch (err) {
                            console.error(`Error processing ${item.file.name}:`, err);
                            setBulkQueue(prev => prev.map((q, idx) => idx === i ? { ...q, status: 'error', error: err.message } : q));
                        }
                    }

                    setBulkResults(results);
                    setStatusMessage('');

                    if (results.length > 0) {
                        setView('bulk-review');
                    } else {
                        setError('All images failed to process. Check your settings and try again.');
                    }
                } catch (e) {
                    console.error('[Bulk Error]', e);
                    setError(`Batch processing failed: ${e.message}`);
                } finally {
                    // Always terminate worker to prevent memory leaks
                    if (worker) {
                        try { await worker.terminate(); } catch (e) { console.warn('Worker termination failed:', e); }
                    }
                    setIsProcessing(false);
                }
            };

            // Cleanup blob URLs when component unmounts or bulk queue changes
            useEffect(() => {
                return () => {
                    // Revoke blob URLs to prevent memory leaks
                    bulkQueue.forEach(item => {
                        if (item.preview && item.preview.startsWith('blob:')) {
                            URL.revokeObjectURL(item.preview);
                        }
                    });
                };
            }, [bulkQueue]);

            // Save settings
            const saveSettings = () => {
                localStorage.setItem('ocr_engine', ocrEngine);
                localStorage.setItem('ai_validation', aiValidation);
                setView('home');
            };

            // Test API key
            const [apiTestResult, setApiTestResult] = useState(null);
            const [apiTesting, setApiTesting] = useState(false);

            const testApiKey = async () => {
                if (!googleApiKey) {
                    setApiTestResult({ success: false, message: 'Please enter an API key first' });
                    return;
                }

                setApiTesting(true);
                setApiTestResult(null);

                try {
                    const response = await fetch(`https://vision.googleapis.com/v1/images:annotate?key=${googleApiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            requests: [{
                                image: { content: 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==' },
                                features: [{ type: 'TEXT_DETECTION' }]
                            }]
                        })
                    });

                    const data = await response.json();

                    if (data.error) {
                        setApiTestResult({ success: false, message: data.error.message });
                    } else {
                        setApiTestResult({ success: true, message: 'API key is valid!' });
                    }
                } catch (e) {
                    setApiTestResult({ success: false, message: e.message });
                } finally {
                    setApiTesting(false);
                }
            };

            // ==================== RENDER FUNCTIONS ====================

            const renderHome = () => (
                <div className="flex flex-col items-center justify-center min-h-screen p-6">
                    {/* Cura.tor Logo */}
                    <div className="mb-8">
                        <svg viewBox="0 0 320 100" xmlns="http://www.w3.org/2000/svg" className="w-64 h-auto">
                            <defs>
                                <linearGradient id="curatorGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style={{stopColor:'#0EA5E9'}} />
                                    <stop offset="100%" style={{stopColor:'#0284C7'}} />
                                </linearGradient>
                                <linearGradient id="curatorGradDark" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style={{stopColor:'#0369A1'}} />
                                    <stop offset="100%" style={{stopColor:'#075985'}} />
                                </linearGradient>
                            </defs>
                            {/* Icon: C + card */}
                            <g transform="translate(5, 15)">
                                <path d="M32 8 A25 25 0 1 0 32 58" stroke="url(#curatorGrad)" strokeWidth="6" fill="none" strokeLinecap="round"/>
                                <rect x="18" y="22" width="28" height="18" rx="3" fill="url(#curatorGradDark)"/>
                                <rect x="22" y="29" width="12" height="2" rx="1" fill="white" opacity="0.8"/>
                                <rect x="22" y="34" width="8" height="2" rx="1" fill="white" opacity="0.5"/>
                                <circle cx="50" cy="12" r="4" fill="url(#curatorGrad)"/>
                            </g>
                            {/* CURA in white */}
                            <text x="75" y="52" fontFamily="Arial Black, Arial, sans-serif" fontSize="32" fontWeight="900" fill="#FFFFFF">CURA</text>
                            {/* Dot */}
                            <circle cx="175" cy="42" r="5" fill="url(#curatorGrad)"/>
                            {/* TOR in blue */}
                            <text x="188" y="52" fontFamily="Arial Black, Arial, sans-serif" fontSize="32" fontWeight="900" fill="url(#curatorGrad)">TOR</text>
                            {/* Tagline */}
                            <rect x="75" y="62" width="30" height="2" rx="1" fill="url(#curatorGrad)"/>
                            <text x="110" y="70" fontFamily="Arial, sans-serif" fontSize="8" fill="#64748B" letterSpacing="1">SMART CONTACT CURATION</text>
                        </svg>
                    </div>

                    {error && (
                        <div className="w-full max-w-sm mb-6 p-4 bg-red-500/10 border border-red-500/30 rounded-xl">
                            <p className="text-red-400 text-sm">{error}</p>
                            <button onClick={() => setError(null)} className="text-red-300 text-xs mt-2 underline">Dismiss</button>
                        </div>
                    )}

                    <div className="grid grid-cols-3 gap-3 w-full max-w-sm mb-8">
                        <div onClick={startCamera} className="p-5 glass rounded-3xl flex flex-col items-center cursor-pointer hover:scale-105 transition-all">
                            <SafeIcon name="camera" className="text-indigo-400 mb-2" />
                            <span className="font-bold text-xs">Scan</span>
                        </div>
                        <div onClick={() => fileInputRef.current.click()} className="p-5 glass rounded-3xl flex flex-col items-center cursor-pointer hover:scale-105 transition-all">
                            <input type="file" ref={fileInputRef} onChange={handleFileUpload} multiple accept="image/*" className="hidden" />
                            <SafeIcon name="upload" className="text-emerald-400 mb-2" />
                            <span className="font-bold text-xs">Upload</span>
                        </div>
                        <div onClick={() => setView('manual')} className="p-5 glass rounded-3xl flex flex-col items-center cursor-pointer hover:scale-105 transition-all">
                            <SafeIcon name="pencil" className="text-purple-400 mb-2" />
                            <span className="font-bold text-xs">Manual</span>
                        </div>
                    </div>

                    <div className="grid grid-cols-2 gap-3 w-full max-w-sm mb-8">
                        <div onClick={() => setView('contacts')} className="p-5 glass rounded-3xl flex flex-col items-center cursor-pointer hover:scale-105 transition-all">
                            <SafeIcon name="users" className="text-cyan-400 mb-2" />
                            <span className="font-bold text-xs">Contacts</span>
                            {contacts.length > 0 && <span className="text-[10px] text-slate-500 mt-1">{contacts.length}</span>}
                        </div>
                        <div onClick={() => setView('settings')} className="p-5 glass rounded-3xl flex flex-col items-center cursor-pointer hover:scale-105 transition-all">
                            <SafeIcon name="settings" className="text-amber-400 mb-2" />
                            <span className="font-bold text-xs">Settings</span>
                        </div>
                    </div>

                    <div className="text-slate-600 text-xs text-center space-y-1">
                        <p>
                            OCR: <span className="text-slate-400">{ocrEngine === 'google' ? 'Google Vision' : 'Tesseract'}</span>
                        </p>
                        <p className="flex items-center justify-center gap-1">
                            {driveConnected ? (
                                <>
                                    <span className="inline-block w-2 h-2 bg-emerald-500 rounded-full"></span>
                                    <span className="text-emerald-400">Synced to Drive</span>
                                    {driveSyncing && <span className="text-slate-500">(syncing...)</span>}
                                </>
                            ) : (
                                <>
                                    <span className="inline-block w-2 h-2 bg-slate-500 rounded-full"></span>
                                    <span>Local storage only</span>
                                </>
                            )}
                        </p>
                    </div>
                </div>
            );

            const renderSettings = () => (
                <div className="flex flex-col min-h-screen">
                    <header className="p-6 glass flex items-center justify-between">
                        <button onClick={() => setView('home')}><SafeIcon name="arrow-left" /></button>
                        <h2 className="font-bold">Settings</h2>
                        <div className="w-6"></div>
                    </header>

                    <div className="p-6 space-y-6 flex-1">
                        {/* OCR Engine Selection */}
                        <div className="space-y-3">
                            <label className="text-xs uppercase tracking-wider text-slate-500 font-bold">OCR Engine</label>
                            <div className="space-y-2">
                                <button
                                    onClick={() => setOcrEngine('tesseract')}
                                    className={`w-full p-4 rounded-xl text-left transition-all ${ocrEngine === 'tesseract' ? 'bg-indigo-500/20 border border-indigo-500/50' : 'glass'}`}
                                >
                                    <div className="font-bold text-sm">Tesseract (Local)</div>
                                    <div className="text-xs text-slate-400 mt-1">Free, runs in browser. No API key needed.</div>
                                </button>
                                <button
                                    onClick={() => setOcrEngine('google')}
                                    className={`w-full p-4 rounded-xl text-left transition-all ${ocrEngine === 'google' ? 'bg-emerald-500/20 border border-emerald-500/50' : 'glass'}`}
                                >
                                    <div className="font-bold text-sm">Google Cloud Vision</div>
                                    <div className="text-xs text-slate-400 mt-1">More accurate. Uses cloud processing.</div>
                                </button>
                            </div>
                        </div>

                        {/* AI Validation Toggle */}
                        <div className="space-y-3">
                            <label className="text-xs uppercase tracking-wider text-slate-500 font-bold">AI Enhancement</label>
                            <button
                                onClick={() => setAiValidation(!aiValidation)}
                                className={`w-full p-4 rounded-xl text-left transition-all flex items-center justify-between ${aiValidation ? 'bg-purple-500/20 border border-purple-500/50' : 'glass'}`}
                            >
                                <div>
                                    <div className="font-bold text-sm">AI-Powered Validation</div>
                                    <div className="text-xs text-slate-400 mt-1">Uses Gemini AI to improve parsing accuracy to 99%</div>
                                </div>
                                <div className={`w-12 h-6 rounded-full transition-all ${aiValidation ? 'bg-purple-500' : 'bg-slate-600'} relative`}>
                                    <div className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-all ${aiValidation ? 'right-1' : 'left-1'}`}></div>
                                </div>
                            </button>
                            {!aiValidation && (
                                <p className="text-xs text-amber-400/80 px-1">
                                    ⚠️ Without AI, parsing relies on rule-based detection only. May be less accurate for complex cards.
                                </p>
                            )}
                        </div>

                        {/* Google Drive Sync */}
                        <div className="space-y-3">
                            <label className="text-xs uppercase tracking-wider text-slate-500 font-bold">Cloud Backup</label>

                            {driveConnected ? (
                                <div className="p-4 glass rounded-xl">
                                    <div className="flex items-center gap-3 mb-3">
                                        <div className="h-10 w-10 bg-gradient-to-br from-blue-500 to-green-500 rounded-full flex items-center justify-center">
                                            <SafeIcon name="cloud" className="w-5 h-5 text-white" />
                                        </div>
                                        <div className="flex-1">
                                            <p className="font-bold text-sm text-emerald-400">Connected to Google Drive</p>
                                            {driveUser && <p className="text-xs text-slate-400">{driveUser.email}</p>}
                                        </div>
                                        {driveSyncing && (
                                            <div className="animate-spin h-4 w-4 border-2 border-emerald-500 border-t-transparent rounded-full"></div>
                                        )}
                                    </div>
                                    {lastSyncTime && (
                                        <p className="text-xs text-slate-500 mb-3">
                                            Last synced: {new Date(lastSyncTime).toLocaleString()}
                                        </p>
                                    )}
                                    <div className="flex gap-2">
                                        <button
                                            onClick={loadFromDrive}
                                            disabled={driveSyncing}
                                            className="flex-1 py-2 text-xs bg-slate-700 rounded-lg disabled:opacity-50 flex items-center justify-center gap-1"
                                        >
                                            <SafeIcon name="refresh-cw" className="w-3 h-3" />
                                            Sync Now
                                        </button>
                                        <button
                                            onClick={disconnectGoogleDrive}
                                            className="flex-1 py-2 text-xs bg-red-500/20 text-red-400 rounded-lg"
                                        >
                                            Disconnect
                                        </button>
                                    </div>
                                </div>
                            ) : (
                                <div className="p-4 glass rounded-xl">
                                    <p className="text-sm mb-2">Sync contacts to your Google Drive</p>
                                    <ul className="text-xs text-slate-400 space-y-1 mb-4">
                                        <li>• Survives cache clearing</li>
                                        <li>• Syncs across devices</li>
                                        <li>• Your data stays private</li>
                                    </ul>
                                    <button
                                        onClick={connectGoogleDrive}
                                        className="w-full py-3 bg-blue-600 rounded-xl font-bold text-sm flex items-center justify-center gap-2"
                                    >
                                        <SafeIcon name="cloud" className="w-4 h-4" />
                                        Connect Google Drive
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>

                    <div className="p-6">
                        <button onClick={saveSettings} className="w-full py-4 bg-white text-slate-950 font-bold rounded-2xl">
                            Save Settings
                        </button>
                    </div>
                </div>
            );

            const renderScan = () => (
                <div className="flex flex-col min-h-screen">
                    <header className="p-6 glass flex items-center justify-between">
                        <button onClick={() => { setView('home'); setCapturedImage(null); if(videoRef.current?.srcObject) videoRef.current.srcObject.getTracks().forEach(t => t.stop()); }}>
                            <SafeIcon name="arrow-left" />
                        </button>
                        <h2 className="font-bold">Scanner</h2>
                        <div className="w-6"></div>
                    </header>

                    <div className="flex-1 p-6 flex flex-col items-center justify-center">
                        <div className="w-full max-w-sm aspect-[1.6/1] glass rounded-2xl overflow-hidden relative">
                            {!capturedImage ? (
                                <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover"></video>
                            ) : (
                                <img src={capturedImage} className="w-full h-full object-cover" />
                            )}
                        </div>

                        {/* Progress indicator */}
                        {isProcessing && (
                            <div className="mt-6 w-full max-w-sm">
                                <div className="flex justify-between text-xs text-slate-400 mb-2">
                                    <span>{statusMessage || 'Processing...'}</span>
                                    <span>{progress}%</span>
                                </div>
                                <div className="h-2 bg-slate-800 rounded-full overflow-hidden">
                                    <div className="h-full bg-gradient-to-r from-indigo-500 to-emerald-500 transition-all" style={{ width: `${progress}%` }}></div>
                                </div>
                            </div>
                        )}

                        {/* Error display */}
                        {error && (
                            <div className="mt-6 w-full max-w-sm p-4 bg-red-500/10 border border-red-500/30 rounded-xl">
                                <p className="text-red-400 text-sm">{error}</p>
                                <div className="flex gap-2 mt-3">
                                    <button onClick={() => setError(null)} className="px-3 py-1 text-xs bg-red-500/20 text-red-300 rounded-lg">Dismiss</button>
                                    <button onClick={() => setView('settings')} className="px-3 py-1 text-xs bg-slate-500/20 text-slate-300 rounded-lg">Settings</button>
                                </div>
                            </div>
                        )}

                        {/* Capture/Process buttons */}
                        <div className="mt-8">
                            {!capturedImage ? (
                                <button onClick={capture} className="w-20 h-20 bg-white rounded-full shadow-lg hover:scale-105 transition-all flex items-center justify-center">
                                    <SafeIcon name="camera" className="text-slate-900 w-8 h-8" />
                                </button>
                            ) : (
                                <div className="flex gap-4">
                                    <button onClick={() => { setCapturedImage(null); startCamera(); }} className="p-4 glass rounded-full">
                                        <SafeIcon name="refresh-cw" />
                                    </button>
                                    <button onClick={runOCR} disabled={isProcessing} className="px-8 py-4 bg-emerald-500 rounded-2xl font-bold flex items-center gap-2 disabled:opacity-50">
                                        {isProcessing ? (
                                            <div className="animate-spin h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                                        ) : (
                                            <SafeIcon name="scan" />
                                        )}
                                        {isProcessing ? 'Processing...' : 'Process OCR'}
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );

            const renderReview = () => (
                <div className="flex flex-col min-h-screen">
                    <header className="p-6 glass flex items-center justify-between">
                        <button onClick={() => { setView('scan'); setOcrResult(null); startCamera(); }}><SafeIcon name="arrow-left" /></button>
                        <h2 className="font-bold">Review</h2>
                        <div className="w-6"></div>
                    </header>

                    <div className="p-6 space-y-4 flex-1 overflow-y-auto">
                        {capturedImage && <img src={capturedImage} className="w-full rounded-2xl mb-4" />}

                        {/* Confidence & Raw Text */}
                        <div className="p-3 glass rounded-xl">
                            <div className="flex justify-between items-center">
                                <span className="text-xs text-slate-500">
                                    Confidence: <span className={ocrResult?.confidence > 70 ? 'text-emerald-400' : 'text-amber-400'}>{Math.round(ocrResult?.confidence || 0)}%</span>
                                </span>
                                <button
                                    onClick={() => setOcrResult(prev => ({ ...prev, showRawText: !prev.showRawText }))}
                                    className="text-xs text-slate-400 hover:text-white"
                                >
                                    {ocrResult?.showRawText ? 'Hide' : 'Edit'} Raw Text
                                </button>
                            </div>
                            {ocrResult?.showRawText && (
                                <div className="mt-3">
                                    <textarea
                                        className="w-full p-3 bg-slate-900 rounded-lg text-xs text-slate-300 whitespace-pre-wrap resize-none font-mono"
                                        rows={6}
                                        value={ocrResult.rawText || ''}
                                        onChange={(e) => setOcrResult(prev => ({ ...prev, rawText: e.target.value }))}
                                        placeholder="Edit raw OCR text..."
                                    />
                                    <button
                                        onClick={async () => {
                                            const reparsed = await parseWithValidation(ocrResult.rawText, aiValidation);
                                            setOcrResult(prev => ({
                                                ...prev,
                                                ...reparsed,
                                                rawText: prev.rawText,
                                                confidence: prev.confidence,
                                                showRawText: prev.showRawText
                                            }));
                                        }}
                                        className="mt-2 px-4 py-2 bg-indigo-500/20 text-indigo-400 rounded-lg text-xs hover:bg-indigo-500/30"
                                    >
                                        Re-parse from Raw Text
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* Editable fields */}
                        {['name', 'position', 'company', 'phone', 'email', 'address'].map(field => (
                            <div key={field} className="space-y-1">
                                <label className="text-xs uppercase tracking-wider text-slate-500 font-bold">{field}</label>
                                <input
                                    className="w-full p-4 glass rounded-xl text-sm"
                                    value={ocrResult?.[field] || ''}
                                    onChange={(e) => setOcrResult(prev => ({ ...prev, [field]: e.target.value }))}
                                    placeholder={`Enter ${field}`}
                                />
                            </div>
                        ))}

                        <div className="space-y-1">
                            <label className="text-xs uppercase tracking-wider text-slate-500 font-bold">Notes</label>
                            <textarea
                                className="w-full p-4 glass rounded-xl text-sm resize-none"
                                rows={2}
                                value={ocrResult?.notes || ''}
                                onChange={(e) => setOcrResult(prev => ({ ...prev, notes: e.target.value }))}
                                placeholder="Add notes..."
                            />
                        </div>
                    </div>

                    <div className="p-6">
                        <button onClick={() => saveContact(ocrResult)} className="w-full py-4 bg-white text-slate-950 font-bold rounded-2xl">
                            Save Contact
                        </button>
                    </div>
                </div>
            );

            // Ref for adding more files in upload view
            const addMoreFilesRef = useRef(null);

            const handleAddMoreFiles = (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                const newItems = files.map(f => ({
                    id: Math.random().toString(36).substr(2, 9),
                    file: f,
                    preview: URL.createObjectURL(f),
                    status: 'queued'
                }));
                setBulkQueue(prev => [...prev, ...newItems]);
                e.target.value = ''; // Reset input so same files can be selected again
            };

            const renderUpload = () => (
                <div className="flex flex-col min-h-screen">
                    <header className="p-6 glass flex items-center justify-between">
                        <button onClick={() => { setView('home'); setBulkQueue([]); }}><SafeIcon name="arrow-left" /></button>
                        <h2 className="font-bold">Upload Queue ({bulkQueue.length})</h2>
                        <button onClick={() => addMoreFilesRef.current?.click()} className="text-emerald-400">
                            <SafeIcon name="plus" />
                        </button>
                        <input type="file" ref={addMoreFilesRef} onChange={handleAddMoreFiles} multiple accept="image/*" className="hidden" />
                    </header>

                    {/* Error display */}
                    {error && (
                        <div className="mx-6 mt-4 p-4 bg-red-500/10 border border-red-500/30 rounded-xl">
                            <p className="text-red-400 text-sm">{error}</p>
                            <div className="flex gap-2 mt-3">
                                <button onClick={() => setError(null)} className="px-3 py-1 text-xs bg-red-500/20 text-red-300 rounded-lg">Dismiss</button>
                                <button onClick={() => setView('settings')} className="px-3 py-1 text-xs bg-slate-500/20 text-slate-300 rounded-lg">Settings</button>
                            </div>
                        </div>
                    )}

                    {/* Status display */}
                    {isProcessing && statusMessage && (
                        <div className="mx-6 mt-4 p-4 bg-indigo-500/10 border border-indigo-500/30 rounded-xl flex items-center gap-3">
                            <div className="animate-spin h-5 w-5 border-2 border-indigo-500 border-t-transparent rounded-full"></div>
                            <span className="text-indigo-400 text-sm">{statusMessage}</span>
                        </div>
                    )}

                    <div className="p-6 space-y-3 flex-1 overflow-y-auto">
                        {bulkQueue.length === 0 ? (
                            <div className="text-center py-12">
                                <SafeIcon name="image" className="text-slate-600 mx-auto mb-4" />
                                <p className="text-slate-500">No files in queue</p>
                                <button
                                    onClick={() => addMoreFilesRef.current?.click()}
                                    className="mt-4 px-4 py-2 bg-emerald-500/20 text-emerald-400 rounded-lg text-sm"
                                >
                                    Add Files
                                </button>
                            </div>
                        ) : (
                            bulkQueue.map((item, idx) => (
                                <div key={item.id} className={`p-4 glass rounded-2xl flex gap-4 items-center ${item.status === 'error' ? 'border border-red-500/30' : ''}`}>
                                    <img src={item.preview} className="w-12 h-12 rounded-lg object-cover" />
                                    <div className="flex-1 min-w-0">
                                        <p className="text-sm truncate">{item.file.name}</p>
                                        <p className={`text-xs mt-1 ${
                                            item.status === 'completed' ? 'text-emerald-400' :
                                            item.status === 'processing' ? 'text-indigo-400' :
                                            item.status === 'error' ? 'text-red-400' : 'text-slate-500'
                                        }`}>
                                            {item.status === 'error' ? item.error : item.status}
                                        </p>
                                    </div>
                                    {item.status === 'completed' && <SafeIcon name="check-circle" className="text-emerald-400" />}
                                    {item.status === 'processing' && <div className="animate-spin h-5 w-5 border-2 border-indigo-500 border-t-transparent rounded-full"></div>}
                                    {item.status === 'error' && <SafeIcon name="x-circle" className="text-red-400" />}
                                    {item.status === 'queued' && !isProcessing && (
                                        <button
                                            onClick={() => setBulkQueue(prev => prev.filter((_, i) => i !== idx))}
                                            className="text-slate-400 hover:text-red-400 transition-colors"
                                        >
                                            <SafeIcon name="trash-2" />
                                        </button>
                                    )}
                                </div>
                            ))
                        )}
                    </div>

                    <div className="p-6">
                        <button
                            onClick={processBulk}
                            disabled={isProcessing || bulkQueue.length === 0}
                            className="w-full py-4 bg-white text-slate-950 font-bold rounded-2xl flex items-center justify-center gap-2 disabled:opacity-50"
                        >
                            {isProcessing ? (
                                <>
                                    <div className="animate-spin h-5 w-5 border-2 border-slate-900 border-t-transparent rounded-full"></div>
                                    Processing...
                                </>
                            ) : (
                                <>
                                    <SafeIcon name="play" className="text-slate-900" />
                                    Start OCR
                                </>
                            )}
                        </button>
                    </div>
                </div>
            );

            const renderBulkReview = () => (
                <div className="flex flex-col min-h-screen">
                    <header className="p-6 glass flex items-center justify-between">
                        <button onClick={() => { setView('home'); setBulkResults([]); setBulkQueue([]); }}><SafeIcon name="x" /></button>
                        <h2 className="font-bold">Review ({bulkResults.length})</h2>
                        <div className="w-6"></div>
                    </header>

                    <div className="p-6 space-y-6 flex-1 overflow-y-auto">
                        {bulkResults.map((r, idx) => (
                            <div key={r.id} className="glass rounded-2xl overflow-hidden">
                                <img src={r.image} className="w-full h-32 object-cover" />

                                {/* Confidence & Raw Text toggle */}
                                <div className="p-3 border-b border-white/10">
                                    <div className="flex justify-between items-center">
                                        <span className="text-xs text-slate-500">
                                            {r.fileName} - <span className={r.confidence > 70 ? 'text-emerald-400' : 'text-amber-400'}>{Math.round(r.confidence)}%</span>
                                        </span>
                                        <button
                                            onClick={() => setBulkResults(prev => prev.map((item, i) => i === idx ? { ...item, showRawText: !item.showRawText } : item))}
                                            className="text-[10px] text-slate-400 hover:text-white uppercase"
                                        >
                                            {r.showRawText ? 'Hide' : 'Edit'} Raw
                                        </button>
                                    </div>
                                    {r.showRawText && (
                                        <div className="mt-2">
                                            <textarea
                                                className="w-full p-2 bg-slate-900 rounded text-[10px] text-slate-300 whitespace-pre-wrap resize-none font-mono"
                                                rows={4}
                                                value={r.rawText || ''}
                                                onChange={(e) => setBulkResults(prev => prev.map((item, i) => i === idx ? { ...item, rawText: e.target.value } : item))}
                                                placeholder="Edit raw OCR text..."
                                            />
                                            <button
                                                onClick={async () => {
                                                    const reparsed = await parseWithValidation(r.rawText, aiValidation);
                                                    setBulkResults(prev => prev.map((item, i) => i === idx ? {
                                                        ...item,
                                                        ...reparsed,
                                                        rawText: item.rawText,
                                                        confidence: item.confidence,
                                                        showRawText: item.showRawText,
                                                        image: item.image,
                                                        fileName: item.fileName,
                                                        id: item.id
                                                    } : item));
                                                }}
                                                className="mt-1 px-3 py-1 bg-indigo-500/20 text-indigo-400 rounded text-[10px] hover:bg-indigo-500/30"
                                            >
                                                Re-parse
                                            </button>
                                        </div>
                                    )}
                                </div>

                                <div className="p-4 space-y-2">
                                    {['name', 'position', 'company', 'phone', 'email'].map(field => (
                                        <input
                                            key={field}
                                            className="w-full bg-slate-800 rounded-lg px-3 py-2 text-sm"
                                            placeholder={field.charAt(0).toUpperCase() + field.slice(1)}
                                            value={r[field] || ''}
                                            onChange={e => setBulkResults(prev => prev.map((item, i) => i === idx ? { ...item, [field]: e.target.value } : item))}
                                        />
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>

                    <div className="p-6">
                        <button
                            onClick={() => {
                                const newContacts = bulkResults.map(r => ({ ...r, id: Date.now() + Math.random(), createdAt: new Date().toISOString() }));
                                const updatedContacts = [...newContacts, ...contacts];
                                setContacts(updatedContacts);
                                localStorage.setItem('demo_contacts', JSON.stringify(updatedContacts));
                                setBulkResults([]);
                                setBulkQueue([]);
                                setView('contacts');
                            }}
                            className="w-full py-4 bg-emerald-500 text-white font-bold rounded-2xl"
                        >
                            Save All ({bulkResults.length})
                        </button>
                    </div>
                </div>
            );

            // CSV Export function
            const exportToCSV = () => {
                if (contacts.length === 0) return;

                const headers = ['Name', 'Position', 'Company', 'Phone', 'Email', 'Address', 'Notes', 'Created At'];
                const csvRows = [headers.join(',')];

                contacts.forEach(c => {
                    const row = [
                        `"${(c.name || '').replace(/"/g, '""')}"`,
                        `"${(c.position || '').replace(/"/g, '""')}"`,
                        `"${(c.company || '').replace(/"/g, '""')}"`,
                        `"${(c.phone || '').replace(/"/g, '""')}"`,
                        `"${(c.email || '').replace(/"/g, '""')}"`,
                        `"${(c.address || '').replace(/"/g, '""')}"`,
                        `"${(c.notes || '').replace(/"/g, '""')}"`,
                        `"${(c.createdAt || '').replace(/"/g, '""')}"`
                    ];
                    csvRows.push(row.join(','));
                });

                const csvContent = csvRows.join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `contacts_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            // Generate vCard format for a single contact
            const generateVCard = (contact) => {
                // Parse name into parts (simple split)
                const nameParts = (contact.name || 'Unknown').split(' ');
                const firstName = nameParts[0] || '';
                const lastName = nameParts.slice(1).join(' ') || '';

                // Handle multiple phones (split by " / ")
                const phones = (contact.phone || '').split(' / ').filter(p => p.trim());

                // Build vCard
                let vcard = 'BEGIN:VCARD\n';
                vcard += 'VERSION:3.0\n';
                vcard += `FN:${contact.name || 'Unknown'}\n`;
                vcard += `N:${lastName};${firstName};;;\n`;

                if (contact.company) {
                    vcard += `ORG:${contact.company}\n`;
                }
                if (contact.position) {
                    vcard += `TITLE:${contact.position}\n`;
                }

                // Add all phone numbers
                phones.forEach((phone, idx) => {
                    const type = idx === 0 ? 'CELL' : 'WORK';
                    vcard += `TEL;TYPE=${type}:${phone.trim()}\n`;
                });

                if (contact.email) {
                    vcard += `EMAIL:${contact.email}\n`;
                }
                if (contact.address) {
                    // vCard address format: PO Box;Extended;Street;City;Region;Postal;Country
                    vcard += `ADR;TYPE=WORK:;;${contact.address};;;;\n`;
                }
                if (contact.notes) {
                    vcard += `NOTE:${contact.notes.replace(/\n/g, '\\n')}\n`;
                }

                vcard += 'END:VCARD\n';
                return vcard;
            };

            // Export single contact as vCard (for "Save to Phone")
            const exportSingleVCard = (contact) => {
                const vcard = generateVCard(contact);
                const blob = new Blob([vcard], { type: 'text/vcard;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                // Use contact name for filename, sanitized
                const safeName = (contact.name || 'contact').replace(/[^a-zA-Z0-9]/g, '_');
                link.download = `${safeName}.vcf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            // Export all contacts as vCard
            const exportAllVCards = () => {
                if (contacts.length === 0) return;

                // Multiple vCards can be in one file
                const vcards = contacts.map(c => generateVCard(c)).join('\n');
                const blob = new Blob([vcards], { type: 'text/vcard;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `curator_contacts_${new Date().toISOString().split('T')[0]}.vcf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            };

            // Export menu state
            const [showExportMenu, setShowExportMenu] = useState(false);

            const renderContacts = () => (
                <div className="flex flex-col min-h-screen">
                    <header className="p-6 glass flex items-center justify-between relative">
                        <button onClick={() => setView('home')}><SafeIcon name="arrow-left" /></button>
                        <h2 className="font-bold">Contacts ({contacts.length})</h2>
                        {contacts.length > 0 ? (
                            <div className="relative">
                                <button onClick={() => setShowExportMenu(!showExportMenu)} className="text-emerald-400">
                                    <SafeIcon name="download" />
                                </button>
                                {showExportMenu && (
                                    <div className="absolute right-0 top-10 glass rounded-xl p-2 min-w-[160px] z-50 shadow-xl">
                                        <button
                                            onClick={() => { exportAllVCards(); setShowExportMenu(false); }}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-white/10 rounded-lg flex items-center gap-2"
                                        >
                                            <SafeIcon name="user-plus" className="w-4 h-4" />
                                            Save to Phone (.vcf)
                                        </button>
                                        <button
                                            onClick={() => { exportToCSV(); setShowExportMenu(false); }}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-white/10 rounded-lg flex items-center gap-2"
                                        >
                                            <SafeIcon name="table" className="w-4 h-4" />
                                            Export as CSV
                                        </button>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <div className="w-6"></div>
                        )}
                    </header>

                    {/* Close menu when clicking outside */}
                    {showExportMenu && (
                        <div className="fixed inset-0 z-40" onClick={() => setShowExportMenu(false)}></div>
                    )}

                    <div className="p-6 space-y-4 flex-1 overflow-y-auto">
                        {contacts.length === 0 ? (
                            <div className="text-center py-12">
                                <SafeIcon name="users" className="text-slate-600 mx-auto mb-4" />
                                <p className="text-slate-500">No contacts yet</p>
                                <p className="text-slate-600 text-sm mt-1">Scan or upload business cards to get started</p>
                            </div>
                        ) : (
                            contacts.map((c, i) => (
                                <div key={c.id || i} className="p-4 glass rounded-2xl">
                                    <div className="flex gap-4">
                                        <div className="h-12 w-12 bg-gradient-to-br from-indigo-500 to-emerald-500 rounded-full flex items-center justify-center font-bold text-lg flex-shrink-0">
                                            {(c.name || '?')[0].toUpperCase()}
                                        </div>
                                        <div className="flex-1 min-w-0">
                                            <h4 className="font-bold truncate">{c.name}</h4>
                                            {c.position && <p className="text-xs text-slate-400 truncate">{c.position}</p>}
                                            {c.company && <p className="text-xs text-slate-500 truncate">{c.company}</p>}
                                        </div>
                                    </div>
                                    <div className="mt-3 pt-3 border-t border-white/10 flex gap-2">
                                        {c.phone && (
                                            <a href={`tel:${c.phone.split(' / ')[0]}`} className="flex-1 py-2 text-center text-xs bg-slate-800 rounded-lg hover:bg-slate-700 flex items-center justify-center gap-1">
                                                <SafeIcon name="phone" className="w-3 h-3" />
                                                Call
                                            </a>
                                        )}
                                        {c.email && (
                                            <a href={`mailto:${c.email}`} className="flex-1 py-2 text-center text-xs bg-slate-800 rounded-lg hover:bg-slate-700 flex items-center justify-center gap-1">
                                                <SafeIcon name="mail" className="w-3 h-3" />
                                                Email
                                            </a>
                                        )}
                                        <button
                                            onClick={() => exportSingleVCard(c)}
                                            className="flex-1 py-2 text-center text-xs bg-emerald-600 rounded-lg hover:bg-emerald-500 flex items-center justify-center gap-1"
                                        >
                                            <SafeIcon name="user-plus" className="w-3 h-3" />
                                            Save
                                        </button>
                                        <button
                                            onClick={() => {
                                                if (confirm(`Delete ${c.name || 'this contact'}?`)) {
                                                    setContacts(prev => prev.filter(contact => contact.id !== c.id));
                                                }
                                            }}
                                            className="py-2 px-3 text-center text-xs bg-red-500/20 text-red-400 rounded-lg hover:bg-red-500/30 flex items-center justify-center"
                                        >
                                            <SafeIcon name="trash-2" className="w-3 h-3" />
                                        </button>
                                    </div>
                                </div>
                            ))
                        )}
                    </div>

                    {contacts.length > 0 && (
                        <div className="p-6">
                            <button
                                onClick={() => {
                                    if (confirm('Delete all contacts?')) {
                                        setContacts([]);
                                        localStorage.removeItem('demo_contacts');
                                    }
                                }}
                                className="w-full py-3 glass text-red-400 rounded-xl text-sm"
                            >
                                Clear All Contacts
                            </button>
                        </div>
                    )}
                </div>
            );

            const renderManual = () => (
                <div className="flex flex-col min-h-screen">
                    <header className="p-6 glass flex items-center justify-between">
                        <button onClick={() => { setView('home'); setManualEntry({ name: '', position: '', company: '', phone: '', email: '', address: '', notes: '' }); }}>
                            <SafeIcon name="arrow-left" />
                        </button>
                        <h2 className="font-bold">Add Contact</h2>
                        <div className="w-6"></div>
                    </header>

                    <div className="p-6 space-y-4 flex-1 overflow-y-auto">
                        {['name', 'position', 'company', 'phone', 'email', 'address'].map(field => (
                            <div key={field} className="space-y-1">
                                <label className="text-xs uppercase tracking-wider text-slate-500 font-bold">{field}</label>
                                <input
                                    className="w-full p-4 glass rounded-xl text-sm"
                                    value={manualEntry[field]}
                                    onChange={(e) => setManualEntry(prev => ({ ...prev, [field]: e.target.value }))}
                                    placeholder={`Enter ${field}`}
                                    type={field === 'email' ? 'email' : field === 'phone' ? 'tel' : 'text'}
                                />
                            </div>
                        ))}

                        <div className="space-y-1">
                            <label className="text-xs uppercase tracking-wider text-slate-500 font-bold">Notes</label>
                            <textarea
                                className="w-full p-4 glass rounded-xl text-sm resize-none"
                                rows={3}
                                value={manualEntry.notes}
                                onChange={(e) => setManualEntry(prev => ({ ...prev, notes: e.target.value }))}
                                placeholder="Add notes..."
                            />
                        </div>
                    </div>

                    <div className="p-6">
                        <button
                            onClick={() => {
                                if (!manualEntry.name.trim()) {
                                    setError('Please enter at least a name');
                                    return;
                                }
                                const newContact = {
                                    ...manualEntry,
                                    id: Date.now(),
                                    createdAt: new Date().toISOString()
                                };
                                const newContacts = [newContact, ...contacts];
                                setContacts(newContacts);
                                localStorage.setItem('demo_contacts', JSON.stringify(newContacts));
                                setManualEntry({ name: '', position: '', company: '', phone: '', email: '', address: '', notes: '' });
                                setView('contacts');
                            }}
                            className="w-full py-4 bg-white text-slate-950 font-bold rounded-2xl"
                        >
                            Save Contact
                        </button>
                    </div>
                </div>
            );

            // Main render
            if (view === 'home') return renderHome();
            if (view === 'settings') return renderSettings();
            if (view === 'scan') return renderScan();
            if (view === 'review') return renderReview();
            if (view === 'upload') return renderUpload();
            if (view === 'bulk-review') return renderBulkReview();
            if (view === 'contacts') return renderContacts();
            if (view === 'manual') return renderManual();
            return null;
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>

    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('[Cura.tor] Service Worker registered:', registration.scope);

                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    // New version available
                                    console.log('[Cura.tor] New version available!');
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.log('[Cura.tor] Service Worker registration failed:', error);
                    });
            });
        }

        // Handle install prompt for "Add to Home Screen"
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            console.log('[Cura.tor] Install prompt available');
        });
    </script>
</body>

</html>
